
╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                                                                                                       ║
  ₍ᐢ⑅.ˬ.ᐢ₎ ₍ᐢ.ˬ.⑅ᐢ₎ ₍ᐢ⑅.ˬ.ᐢ₎ ₍ᐢ.ˬ.⑅ᐢ₎ ₍ᐢ⑅.ˬ.ᐢ₎ ₍ᐢ.ˬ.⑅ᐢ₎ ₍ᐢ⑅.ˬ.ᐢ₎ ₍ᐢ.ˬ.⑅ᐢ₎ ₍ᐢ⑅.ˬ.ᐢ₎ ₍ᐢ.ˬ.⑅ᐢ₎ ₍ᐢ⑅.ˬ.ᐢ₎ ₍ᐢ.ˬ.⑅ᐢ₎ ₍ᐢ⑅.ˬ.ᐢ₎ ₍ᐢ.ˬ.⑅ᐢ₎
║                                                                                                                       ║
║                                                    Estado Inicial                                                     ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

 0. PC <= 0;                                                                                                             -- Se inicializa PC en 0
    -> X 1.

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                                         Fetch                                                         ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

 1. MAR <= PC;                                                                                                           -- Se carga la direccion del PC al MAR
    -> X 2.

 2. MemoryAddress = MAR;
    Read = 1;                                                                                                            --Fetch ciclo 1
    -> X 3.

 3. MemoryAddress = MAR;
    Read = 1;                                                                                                            --Fetch ciclo 2
    -> X 4.

 4. MemoryAddress = MAR;
    Read = 1;                                                                                                            --Fetch ciclo 3
    IR <= Instruction;
    -> X 5.

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                                        Decode                                                         ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

 5. Pc <= Inc(Pc);                                                                                                       -- Posiciones del IR
    ->                                                                                                                   --[6.....0][14...12][30]
(IR[6]’ . IR[5]’ . IR[4]  . IR[3]’ . IR[2]  . IR[1]  . IR[0]                                          X 6) +             -- 0010111                   auipc
(IR[6]’ . IR[5]  . IR[4]  . IR[3]’ . IR[2]  . IR[1]  . IR[0]                                          X 8) +             -- 0110111                   lui
(IR[6]  . IR[5]  . IR[4]’ . IR[3]  . IR[2]  . IR[1]  . IR[0]                                          X 9) +             -- 1101111                   jal
(IR[6]  . IR[5]  . IR[4]’ . IR[3]’ . IR[2]  . IR[1]  . IR[0]                                          X 9) +             -- 1100111                   jalr
(IR[6]  . IR[5]  . IR[4]’ . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]’ . IR[13]’                     X15) +             -- 1100011    00C            beq/bne
(IR[6]  . IR[5]  . IR[4]’ . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]  . IR[13]’                     X19) +             -- 1100011    10C            blt/bge
(IR[6]  . IR[5]  . IR[4]’ . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]  . IR[13]                      X21) +             -- 1100011    11C            bltu/bgeu
(IR[6]’ . IR[5]’ . IR[4]’ . IR[3]’ . IR[2]’ . IR[1]  . IR[0]                                          X23) +             -- 0000011    CCC            lb/lh/lw/lbu/lhu
(IR[6]’ . IR[5]  . IR[4]’ . IR[3]’ . IR[2]’ . IR[1]  . IR[0]                                          X23) +             -- 0100011    CCC            sb/sh/sw
(IR[6]’ . IR[5]’ . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]’ . IR[13]’ . IR[12]’           X38) +             -- 0010011    000            addi
(IR[6]’ . IR[5]’ . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]’ . IR[13]  . IR[12]’           X40) +             -- 0010011    010            slti
(IR[6]’ . IR[5]’ . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]’ . IR[13]  . IR[12]            X44) +             -- 0010011    011            sltiu
(IR[6]’ . IR[5]’ . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]  . IR[13]’ . IR[12]’           X46) +             -- 0010011    100            xori
(IR[6]’ . IR[5]’ . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]  . IR[13]  . IR[12]’           X47) +             -- 0010011    110            ori
(IR[6]’ . IR[5]’ . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]  . IR[13]  . IR[12]            X48) +             -- 0010011    111            andi
(IR[6]’ . IR[5]’ . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]            . IR[13]’ . IR[12]            X49) +             -- 0010011    C01    C       slli/srli/srai
(IR[6]’ . IR[5]  . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]’ . IR[13]’ . IR[12]’ . IR[30]’ X53) +             -- 0110011    000    0       add
(IR[6]’ . IR[5]  . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]’ . IR[13]’ . IR[12]’ . IR[30]  X55) +             -- 0110011    000    1       sub
(IR[6]’ . IR[5]  . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]            . IR[13]’ . IR[12]            X58) +             -- 0110011    C01    C       sll/srl/sra
(IR[6]’ . IR[5]  . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]’ . IR[13]  . IR[12]’           X60) +             -- 0110011    010            slt
(IR[6]’ . IR[5]  . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]’ . IR[13]  . IR[12]            X62) +             -- 0110011    011            sltu
(IR[6]’ . IR[5]  . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]  . IR[13]’ . IR[12]’           X64) +             -- 0110011    100            xor
(IR[6]’ . IR[5]  . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]  . IR[13]  . IR[12]’           X65) +             -- 0110011    110            or
(IR[6]’ . IR[5]  . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]  . IR[13]  . IR[12]            X66) +             -- 0110011    111            and
(IR[6]  . IR[5]  . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]                                          X67) +             -- 1110011    CCC            csrrw/csrrs/csrrc/csrrwi/csrrsi/csrrci
(IR[6]’ . IR[5]  . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]’ . IR[13]’ . IR[12]’           X74) .             -- 0110011    000            mul

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                                         AUIPC                                                         ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

 6. Salida_ALU           = Suma(Pc,( IR(31:12), (12 T 0) ));                                                             -- Escribe en Registers direccion IR(11:7) la suma del PC con IR(31:12)
    -> X 8.                                                                                                              -- desplazado 12 bits a la izquierda

 7. Registers[IR(11:7)] <= Suma(Pc,( IR(31:12), (12 T 0) ));                                                             -- Se repite la accion del estado 7, mientras la suma se efectua
    -> X 1.

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                                          LUI                                                          ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

 8. Registers[IR(11:7)](31:12) <= IR(31:12);                                                                             -- Escribe en Registers direccion IR(11:7) el dato del IR(31:12)
    Registers[IR(11:7)](11: 0) <= '0';                                                                                   -- y rellena los 11 LSB con 0
    -> X 1.

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                                       JAL/JALR                                                        ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

 9. Salida_ALU           = Suma(Pc,4);                                                                                   -- Escribe en Registers direccion IR(11:7) la suma del PC con 4
    -> X10.

10. Registers[IR(11:7)] <= Suma(Pc,4);                                                                                   -- Se repite la accion del estado 9 y se selecciona el siguiente estado
    -> (IR[3]  X11) +                                                                                                    -- 1 JAL
       (IR[3]’ X13) .                                                                                                    -- 0 JALR

11. Salida_ALU = Suma(PC, sext( IR(31:12) ));                                                                            -- Escribe en PC la suma entre el PC actual y el valor de IR(12:31) al
    -> X12.                                                                                                              -- hacerle offset extendido en signo (una suerte de shift aritmetico)

12. PC        <= Suma(PC, sext( IR(31:12) ));                                                                            -- Se repite la accion del estado 11, mientras la suma se efectua
    -> X 1.

13. Salida_ALU = Suma(Registers[IR(19:15)], sext(IR(31:12)) );                                                           -- Escribe en PC la suma entre Registers direccion IR(19:15) y el
    -> X14.                                                                                                              -- valor de IR(12:31) al hacerle offset extendido en signo

14. PC        <= Suma(Registers[IR(19:15)], sext(IR(31:12)) );                                                           -- Se repite la accion del estado 13, mientras la suma se efectua
    -> X 1.

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                                INSTRUCCIONES DE SALTOS                                                ║
║                                                15. BEQ  /BNE                                                          ║
║                                                19. BLT  /BGE                                                          ║
║                                                21. BLTU /BGEU                                                         ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

15. Salida_ALU = Resta(Registers[IR(24:20)],Registers[IR(19:15)]);                                                       -- Se resta el valor de Registers direccion IR(24:20) con Registers
    -> 16                                                                                                                -- direccion IR(14:19) pero no guarda el resultado

16. Salida_ALU = Resta(Registers[IR(24:20)],Registers[IR(19:15)]);                                                       -- Se repite la accion del estado 15, mientras la resta se efectua
    ->
(IR[12]'. ALU_Control[1]  X17) +                                                                                         -- Si se desea que sean iguales   , y son iguales    va al estado 17
(IR[12]'. ALU_Control[1]' X 1) +                                                                                         -- Si se desea que sean iguales   , y son diferentes va al estado  1
(IR[12] . ALU_Control[1]  X 1) +                                                                                         -- Si se desea que sean diferentes, y son iguales    va al estado  1
(IR[12] . ALU_Control[1]' X17) .                                                                                         -- Si se desea que sean diferentes, y son diferentes va al estado 17

17. Salida_ALU = Suma(PC, ((20 T IR(12)) ,IR(31), IR(7), IR(30:25), IR(11:8)));                                          -- Se suma PC con un arreglo de valores del IR
    ->  X18.

18. PC        <= Suma(PC, ((20 T IR(12)) ,IR(31), IR(7), IR(30:25), IR(11:8)));                                          -- Se repite la accion del estado 17, mientras la suma se efectua
    -> X 1.

19. Salida_ALU = Resta      ( Registers[IR(19:15)], Registers[IR(24:20)] );                                              -- Se compara el valor de Registers direccion IR(24:20) con Registers
    -> X20.                                                                                                              -- direccion IR(14:19)La comparacion tiene en cuenta el complemento a2

20. Salida_ALU = Resta      ( Registers[IR(19:15)], Registers[IR(24:20)] );                                              -- Se repite la accion del estado 19, mientras la comparacion se hace
    ->
(ALU_Control[2] . ALU_Control[1]’ . IR[12]’ X17) +                                                                       -- rs1<rs2 blt
(ALU_Control[2]’. ALU_Control[1]’ . IR[12]’ X 1) +                                                                       -- rs1>rs2 blt
(ALU_Control[2]’. ALU_Control[1]’ . IR[12]  X17) +                                                                       -- rs1>rs2 bge
(ALU_Control[2] . ALU_Control[1]’ . IR[12]  X 1) +                                                                       -- rs1<rs2 bge
(                 ALU_Control[1]  .         X 1) +                                                                       -- sr1=rs2 bge blt

21. Salida_ALU = resta( Registers[ IR[19:15]], Registers[ IR[24:20]]);                                                   -- Se resta el valor de Registers direccion IR(24:20) con Registers
    -> X22.                                                                                                              -- direccion IR(14:19) pero no guarda el resultado

22. Salida_ALU = resta( Registers[ IR[19:15]], Registers[ IR[24:20]]);                                                   -- Se repite la accion del estado 21, mientras la resta se efectua
    ->
(ALU_Control[3] . ALU_Control[1]’ . IR[12]’ X 1) +                                                                       -- rs1>rs2 bltu
(ALU_Control[3]’. ALU_Control[1]’ . IR[12]’ X17) +                                                                       -- rs1<rs2 bltu
(                 ALU_Control[1]            X 1) +                                                                       -- rs1=rs2 bltu bgeu
(ALU_Control[3] . ALU_Control[1]’ . IR[12]  X17) +                                                                       -- rs1>rs2 bgeu
(ALU_Control[3]’. ALU_Control[1]’ . IR[12]  X 1) +                                                                       -- rs1<rs2 bgeu

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                     PREPARACION DE LECTURA/ESCRITURA EN MEMORIA                                       ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

23. Salida_ALU = Suma(Registers[IR(19:15)],IR[31:20]);                                                                   -- Se suma Registers direccion IR(19:15) con IR(31:20)
    -> X24.

24. MAR       <= Suma(Registers[IR(19:15)],IR[31:20]);                                                                   -- Se repite la accion del estado 23, mientras la suma se efectua
    ->
(IR[5]’                   X25) +                                                                                         -- Se decodifica si se requiere leer     un dato
(IR[5] .IR[13]’ . IR[12]’ X32) +                                                                                         -- Se decodifica si se requiere escribir un dato de 1Byte
(IR[5] .IR[13]’ . IR[12]  X34) +                                                                                         -- Se decodifica si se requiere escribir un dato de 2Byte
(IR[5] .IR[13]  . IR[12]’ X36) .                                                                                         -- Se decodifica si se requiere escribir un dato de 4Byte

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                          INSTRUCCIONES DE LECTURA EN MEMORIA                                          ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

25. MemoryAddress = MAR;                                                                                                 -- Se pide el dato de la direccion MAR a la memoria (Ciclo 1)
    Read = 1;
    -> X26.

26. MemoryAddress = MAR;                                                                                                 -- Se pide el dato de la direccion MAR a la memoria (Ciclo 2)
    Read = 1;
    ->
(IR[14]’ . IR[13]’ . IR[12]’ X27) +                                                                                      -- 000 goto LB
(IR[14]’ . IR[13]’ . IR[12]  X28) +                                                                                      -- 001 goto LH
(IR[14]’ . IR[13]  . IR[12]’ X29) +                                                                                      -- 010 goto LW
(IR[14]  . IR[13]’ . IR[12]’ X30) +                                                                                      -- 100 goto LBU
(IR[14]  . IR[13]’ . IR[12]  X31) .                                                                                      -- 101 goto LHU

27. MemoryAddress = MAR;                                                                                                 -- Se pide el dato de la direccion MAR a la memoria (Ciclo 3)
    Read = 1;
    Registers[IR(11:7)]( 7: 0) <= MemoryOut(7: 0);                                                                       -- Se guarda  el LSByte en Registers en la direccion IR(11:7)
    Registers[IR(11:7)](31: 8) <= MemoryOut(7);                                                                          -- Se extiende el signo del valor a guardar
    -> X 1.

28. MemoryAddress = MAR;                                                                                                 -- Se pide el dato de la direccion MAR a la memoria (Ciclo 3)
    Read = 1;
    Registers[IR(11:7)](15: 0) <= MemoryOut(15: 0);                                                                      -- Se guardan los 2 LSBytes en Registers en la direccion IR(11:7)
    Registers[IR(11:7)](31:16) <= MemoryOut(15);                                                                         -- Se extiende el signo del valor a guardar
    -> X 1.

29.MemoryAddress = MAR;                                                                                                  -- Se pide el dato de la direccion MAR a la memoria (Ciclo 3)
    Read = 1;
    Registers[IR(11:7)]        <= MemoryOut;                                                                             -- Se guardan los 4 Bytes en Registers en la direccion IR(11:7)
    -> X 1.

30. MemoryAddress = MAR;                                                                                                 -- Se pide el dato de la direccion MAR a la memoria (Ciclo 3)
    Read = 1;
    Registers[IR(11:7)]( 7: 0) <= MemoryOut(7:0);                                                                        -- Se guarda  el LSByte en Registers en la direccion IR(11:7)
    Registers[IR(11:7)](31: 8) <= '0' ;                                                                                  -- Se rellena el registro con ceros
    -> X 1.

31. MemoryAddress = MAR;                                                                                                 -- Se pide el dato de la direccion MAR a la memoria (Ciclo 3)
    Read = 1;
    Registers[IR(11:7)](15: 0) <= MemoryOut(15:0);                                                                       -- Se guardan los 2 LSBytes en Registers en la direccion IR(11:7)
    Registers[IR(11:7)](31:16) <= '0';                                                                                   -- Se rellena el registro con ceros
    -> X 1.

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                         INSTRUCCIONES DE ESCRITURA EN MEMORIA                                         ║
║                                         32. SB                                                                        ║
║                                         34. SH                                                                        ║
║                                         36. SW                                                                        ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝
32. MemoryAddress = MAR;                                                                                                 -- Se especifica la direccion en la que se va a escribir un dato
    Read = 0;                                                                                                            -- Ciclo 1 de Write
    MemoryIn( 7: 0) = Registers[IR(24:20)]( 7: 0);                                                                       -- Se envia los datos de Registers direccion IR(24:20) del 0 al 7
    MemoryIn(31: 8) = Registers[IR(24:20)](    7);                                                                       -- Se envia el  dato  de Registers direccion IR(24:20) solo el  7
    -> X33.

33. MemoryAddress = MAR;                                                                                                 -- Se especifica la direccion en la que se va a escribir un dato
    Read = 0;                                                                                                            -- Ciclo 2 de Write
    MemoryIn( 7: 0) = Registers[IR(24:20)]( 7: 0);                                                                       -- Se envia los datos de Registers direccion IR(24:20) del 0 al 7
    MemoryIn(31: 8) = Registers[IR(24:20)](    7);                                                                       -- Se envia el  dato  de Registers direccion IR(24:20) solo el  7
    -> X 1.

34. MemoryAddress = MAR;                                                                                                 -- Se especifica la direccion en la que se va a escribir un dato
    Read = 0;                                                                                                            -- Ciclo 1 de Write
    MemoryIn(15: 0) = Registers[IR(24:20)](15: 0);                                                                       -- Se envia los datos de Registers direccion IR(24:20) del 0 al 15
    MemoryIn(31:16) = Registers[IR(24:20)](   15);                                                                       -- Se envia el  dato  de Registers direccion IR(24:20) solo el  15
    -> X35.

35. MemoryAddress = MAR;                                                                                                 -- Se especifica la direccion en la que se va a escribir un dato
    Read = 0;                                                                                                            -- Ciclo 2 de Write
    MemoryIn(15: 0) = Registers[IR(24:20)](15: 0);                                                                       -- Se envia los datos de Registers direccion IR(24:20) del 0 al 15
    MemoryIn(31:16) = Registers[IR(24:20)](   15);                                                                       -- Se envia el  dato  de Registers direccion IR(24:20) solo el  15    -> X 1.

36. MemoryAddress = MAR;                                                                                                 -- Se especifica la direccion en la que se va a escribir un dato
    Read = 0;                                                                                                            -- Ciclo 1 de Write
    MemoryIn = Registers[IR(24:20)];                                                                                     -- Se envia los datos de Registers direccion IR(24:20)
    -> X37.

37. MemoryAddress = MAR;                                                                                                 -- Se especifica la direccion en la que se va a escribir un dato
    Read = 0;                                                                                                            -- Ciclo 2 de Write
    MemoryIn = Registers[IR(24:20)];                                                                                     -- Se envia los datos de Registers direccion IR(24:20)
    -> X 1.

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                              Operaciones de datos en registros con datos inmediatos                                   ║
║                              38. ADDI                                                                                 ║
║                              40. SLTI                                                                                 ║
║                              44. SLTIU                                                                                ║
║                              46. XORI                                                                                 ║
║                              47. ORI                                                                                  ║
║                              48. ANDI                                                                                 ║
║                              49. SLLI /SRLI /SRAI                                                                     ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

38. Salida_ALU           = Suma( Registers[IR(11:7)],IR(31:20) );                                                        -- Suma Registers direccion IR(11:7) con los datos en IR(31:20)
    -> X 36                                                                                                              -- el resultado se guarda en Registers direccion IR(11:7)

39. Registers[IR(11:7)] <= Suma( Registers[IR(11:7)],IR(31:20) );                                                        -- Se repite la accion del estado 38, mientras la suma se efectua
    -> X 1

40. Salida_ALU = Resta( Registers[IR(19:15)], IR[31:20] );                                                               -- Compara el dato en Registers direccion IR(19:15) con el dato
    -> X41.                                                                                                              -- almacenado IR(31:20). Esta comparacion se hace en complemento a 2

41. Salida_ALU = Resta( Registers[IR(19:15)], IR[31:20] );                                                               -- Se repite la accion del estado 40, mientras la comparacion se hace
    ->
(ALU_Control[1]’. ALU_Control[2]’. X42) +                                                                                -- IR(31:20) > Registers direccion IR(19:15)GOTO 42
(ALU_Control[1]’. ALU_Control[2] . X43) +                                                                                -- IR(31:20) < Registers direccion IR(19:15)GOTO 43
(ALU_Control[1]                    X43) .                                                                                -- IR(31:20) = Registers direccion IR(19:15)GOTO 43

42. Registers[IR(11:7)] <= '00000000000000000000000000000001';                                                           -- Se guarda un 0x1 en Registers direccion IR(11:7)
    -> X 1.

43. Registers[IR(11:7)] <='0';                                                                                           -- Se guarda un 0x0 en Registers direccion IR(11:7)
    -> X 1.

44. Salida_ALU = Resta( Registers[IR(19:15)], IR[31:20] );                                                               -- Se resta el dato de Registers direccion IR(19:15) con el dato
    -> X45.                                                                                                              -- almacenado en IR(31:20)

45. Salida_ALU = Resta( Registers[IR(19:15)], IR[31:20] );                                                               -- Se repite la accion del estado 35, mientras la resta se efectua
    ->
(ALU_Control[1]’. ALU_Control[2] . X42) +                                                                                -- IR(31:20) > Registers direccion IR(19:15) GOTO 42
(ALU_Control[1]’. ALU_Control[2]’. X43) +                                                                                -- IR(31:20) < Registers direccion IR(19:15) GOTO 43
(ALU_Control[1]                    X43) .                                                                                -- IR(31:20) = Registers direccion IR(19:15) GOTO 43

46. Registers[IR(11:7)] <= XOR(Registers[IR(19:15)], IR[31:20]);                                                         -- Se hace el XOR entre Registers direccion IR(19:15) con el dato
    -> X 1.                                                                                                              -- almacenado en IR(31:20)

47. Registers[IR(11:7)] <=  OR(Registers[IR(19:15)], IR[31:20]);                                                         -- Se hace el OR entre e Registers direccion IR(19:15) con el dato
    -> X 1.                                                                                                              -- almacenado en IR(31:20)

48. Registers[IR(11:7)] <=  AND(Registers[IR(19:15)], IR[31:20]);                                                        -- Se hace el AND entre e Registers direccion IR(19:15) con el dato
    -> X 1.                                                                                                              -- almacenado en IR(31:20)

49. Counter <= IR(25:20);                                                                                                -- Se carga al Counter el valor de IR(25:20)
    ->
(IR[30]'.IR[14]' X50) +                                                                                                  -- SLLI
(IR[30]'.IR[14]  X51) +                                                                                                  -- SRLI
(IR[31]          X52) .                                                                                                  -- SRAI

50. LogicShiftLeft(IR(19:15));                                                                                           -- Se hace El corrimiento a izquierda 1 vez del dato IR(19:15)
    Counter <= Inc(Counter);                                                                                             -- Se incrementa el conteo de corrimientos realizados
    ->
(CounterControl' X50) +                                                                                                  -- Se va a este mismo estado si el contador no ha llegado al maximo
(CounterControl  X59) .                                                                                                  -- Se va al estado donde se guarda el resultado

51. LogicShiftRight(IR(19:15));                                                                                          -- Se hace El corrimiento a derecha 1 vez del dato IR(19:15)
    Counter <= Inc(Counter);                                                                                             -- Se incrementa el conteo de corrimientos realizados
    ->
(CounterControl' X51) +                                                                                                  -- Se va a este mismo estado si el contador no ha llegado al maximo
(CounterControl  X59) .                                                                                                  -- Se va al estado donde se guarda el resultado

52. ArithmeticShiftRight(IR(19:15));                                                                                     -- Se hace corriemiento aritmetico izquierda 1 vez del dato IR(19:15)
    Counter <= Inc(Counter);                                                                                             -- Se incrementa el conteo de corrimientos realizados
    ->
(CounterControl' X52) +                                                                                                  -- Se va a este mismo estado si el contador no ha llegado al maximo
(CounterControl  X59) .                                                                                                  -- Se va al estado donde se guarda el resultado

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                            Operaciones de datos en registros con datos en registros                                   ║
║                            53. ADD                                                                                    ║
║                            55. SUB                                                                                    ║
║                            58. SLL  /SRL  /SRA                                                                        ║
║                            60. SLT                                                                                    ║
║                            62. SLTU                                                                                   ║
║                            64. XOR                                                                                    ║
║                            65. OR                                                                                     ║
║                            66. AND                                                                                    ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

53. Salida_ALU           = Suma (Registers[IR(19:15)], Registers[IR(24:20)]);                                            -- Se suman los valores almacenados en Registers direcciones IR(19:15)
    -> X54.                                                                                                              -- e IR(24:20) y el resultado va a Registers direccion IR(11:7)

54. Registers[IR(11:7)] <= Suma (Registers[IR(19:15)], Registers[IR(24:20)]);                                            -- Se repite la accion del estado 56, mientras la suma se efectua
    -> X 1.

55. Salida_ALU           = Resta(Registers[IR(19:15)], Registers[IR(24:20)]);                                            -- Se restan los valores almacenados en Registers direcciones IR(19:15)
    -> X56.                                                                                                              -- e IR(24:20) y el resultado va a Registers direccion IR(11:7)

56. Salida_ALU           = Resta(Registers[IR(19:15)], Registers[IR(24:20)]);                                            -- Se repite la accion del estado 58, mientras la resta se efectua
    -> X57.

57. Registers[IR(11:7)] <= Resta(Registers[IR(19:15)], Registers[IR(24:20)]);                                            -- Se repite la accion del estado 59, mientras la resta se efectua
    -> X 1.

58. Counter <= Registers[IR(24:20)]                                                                                      -- Se carga al Counter el valor del Registers direccion IR(25:20)
    ->
(IR[14]’          X 50) +                                                                                                -- SLL
(IR[14] . IR[30]’ X 51) +                                                                                                -- SRL
(IR[14] . IR[30]’ X 52) .                                                                                                -- SRA

59. Registers[IR(11:7)] <= AluShiftRegister;                                                                             -- Se carga el valor del shift realizado al registro indicado
    -> X 1.

60. Salida_ALU = Resta( Registers[IR(19:15)], Registers[ IR(24:20)] );                                                   -- Se compara el valor de Registers direccion IR(24:20) con Registers
    -> X61.                                                                                                              -- direccion IR(19:15)La comparacion tiene en cuenta el complemento a2

61. Salida_ALU = Resta( Registers[IR(19:15)], Registers[ IR(24:20)] );                                                   -- Se repite la accion del estado 19, mientras la comparacion se hace
    ->
(ALU_Control[1]’ . ALU_Control[2]’. X42) +                                                                               -- Registers dir IR(19:15) > Registers dir IR(24:20) GOTO 42
(ALU_Control[1]’ . ALU_Control[2] . X43) +                                                                               -- Registers dir IR(19:15) < Registers dir IR(24:20) GOTO 43
(ALU_Control[1]                     X43) .                                                                               -- Registers dir IR(19:15) = Registers dir IR(24:20) GOTO 43

62. Salida_ALU = Resta( Registers[IR(19:15)], Registers[ IR(24:20)]);                                                    -- Se resta el valor de Registers direccion IR(24:20) con Registers
    -> X63.                                                                                                              -- direccion IR(14:19) pero no guarda el resultado

63. Salida_ALU = Resta( Registers[IR(19:15)], Registers[ IR(24:20)]);                                                    -- Se repite la accion del estado 59, mientras la resta se efectua
    ->
(ALU_Control[1]’. ALU_Control[3] . X42) +                                                                                -- Registers dir IR(19:15) > Registers dir IR(24:20) GOTO 42
(ALU_Control[1]’. ALU_Control[2]’. X43) +                                                                                -- Registers dir IR(19:15) < Registers dir IR(24:20) GOTO 43
(ALU_Control[1]                    X43) .                                                                                -- Registers dir IR(19:15) = Registers dir IR(24:20) GOTO 43

64. Registers[IR(11:7)] <= XOR( Registers[IR(19:15)], Registers[IR(24:20)] );                                            -- Se hace el XOR entre Registers direccion IR(19:15) con el dato
    -> X 1.                                                                                                              -- en Registers direccion (24:20)

65. Registers[IR(11:7)] <= OR ( Registers[IR(19:15)], Registers[IR(24:20)] );                                            -- Se hace el OR  entre Registers direccion IR(19:15) con el dato
    -> X 1.                                                                                                              -- en Registers direccion (24:20)

66. Registers[IR(11:7)] <= AND( Registers[IR(19:15)], Registers[IR(24:20)] );                                            -- Se hace el AND entre Registers direccion IR(19:15) con el dato
    -> X 1.                                                                                                              -- en Registers direccion (24:20)

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                         Instrucciones de Control Status Register                                      ║
║                                         68. CSRRW                                                                     ║
║                                         69. CSRRS                                                                     ║
║                                         70. CSRRC                                                                     ║
║                                         71. CSRRWI                                                                    ║
║                                         72. CSRRSI                                                                    ║
║                                         73. CSRRCI                                                                    ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

67. Registers(IR[11:7]) <= CSR[IR(31:20)];                                                                               -- Se carga el dato de CSR direccion IR(31:20) a Registers
    ->                                                                                                                   -- direccion IR(11:7)
(IR[14]'. IR[13]'. IR[12]  X68) +                                                                                        --CSRRW
(IR[14]'. IR[13] . IR[12]' X69) +                                                                                        --CSRRS
(IR[14]'. IR[13] . IR[12]  X70) +                                                                                        --CSRRC
(IR[14] . IR[13]'. IR[12]  X71) +                                                                                        --CSRRWI
(IR[14] . IR[13] . IR[12]' X72) +                                                                                        --CSRRSI
(IR[14] . IR[13] . IR[12]  X73) .                                                                                        --CSRRCI

68. CSR[IR(31:20)] <= Registers(IR[19:15]);                                                                              -- Se escribe en el CSR direccion IR(31:20) el dato de Registers
    -> X 1.                                                                                                              -- direccion IR(19:15)

69. CSR[IR(31:20)] <= OR ( Registers[IR(11:7)],Registers[IR(19:15)] );                                                   -- Se escribe en el CSR direccion IR(31:20) el resultado del OR  entre
    -> X 1.                                                                                                              -- Registers en las direcciones IR(11:7) e IR(19:15)

70. CSR[IR(31:20)] <= AND( Registers[IR(11:7)],Registers[IR(19:15)] );                                                   -- Se escribe en el CSR direccion IR(31:20) el resultado del AND entre
    -> X 1.                                                                                                              -- Registers en las direcciones IR(11:7) e IR(19:15)

71. CSR[IR[31:20]] <= sext(IR[19:15]);                                                                                   -- El CSR direccion IR(31:20) toma el IR(19:15) con signo extendido
    -> X 1.

72. CSR[IR(31:20)] <= OR ( Registers[IR(11:7)],IR(19:15) );                                                              -- Se escribe en el CSR direccion IR(31:20) el resultado del OR  entre
    -> X 1.                                                                                                              -- Registers en la direccion IR(11:7) y el dato en IR(19:15)

73. CSR[IR(31:20)] <= AND( Registers[IR(11:7)],IR(19:15) );                                                              -- Se escribe en el CSR direccion IR(31:20) el resultado del AND entre
    -> X 1.                                                                                                              -- Registers en la direccion IR(11:7) y el dato en IR(19:15)

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                                          MUL                                                          ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

74. Registers(IR[11:7]) <= Multiply( Registers(IR[19:15]),Registers(IR[24:20]) );                                        -- Se realiza la multiplicacion entre Registers direcciones IR(19:15)
    ->                                                                                                                   -- e IR(24:20)
(ALU_Control[0]' X81) +                                                                                                  -- La operacion aun no acaba, GOTO 81
(ALU_Control[0]  X 1) .                                                                                                  -- La operacion ya termino

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                                                                                                       ║
     (ฅ＾・ω・＾)ฅ ฅ(＾・ω・＾ฅ)  (ฅ＾・ω・＾)ฅ ฅ(＾・ω・＾ฅ)  (ฅ＾・ω・＾)ฅ ฅ(＾・ω・＾ฅ)  (ฅ＾・ω・＾)ฅ ฅ(＾・ω・＾ฅ)
║                                                                                                                       ║
║                                                  FUNCIONES LOGICAS                                                    ║
║                                                                                                                       ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

Resta( DataA, DataB) = Suma (DataA, DataB' , 0x01);
